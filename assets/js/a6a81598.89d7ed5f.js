"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7876],{5680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>g});var i=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",y={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=o,g=d["".concat(l,".").concat(u)]||d[u]||y[u]||a;return n?i.createElement(g,r(r({ref:t},c),{},{components:n})):i.createElement(g,r({ref:t},c))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,r[1]=s;for(var p=2;p<a;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1664:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>y,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var i=n(8168),o=(n(6540),n(5680));const a={sidebar_position:3},r="Part 2: Physics Foundation",s={unversionedId:"tutorials/platformer-tutorial/part-2-physics",id:"tutorials/platformer-tutorial/part-2-physics",title:"Part 2: Physics Foundation",description:"In this part, we'll implement Box2D physics in our platformer game, creating the foundation for realistic movement and collision detection.",source:"@site/docs/tutorials/platformer-tutorial/part-2-physics.md",sourceDirName:"tutorials/platformer-tutorial",slug:"/tutorials/platformer-tutorial/part-2-physics",permalink:"/docs/tutorials/platformer-tutorial/part-2-physics",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Part 1: Project Setup and Assets",permalink:"/docs/tutorials/platformer-tutorial/part-1-setup"},next:{title:"Part 3: Player Character",permalink:"/docs/tutorials/platformer-tutorial/part-3-player"}},l={},p=[{value:"What We&#39;ll Accomplish",id:"what-well-accomplish",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Step 1: Understanding Box2D Integration",id:"step-1-understanding-box2d-integration",level:2},{value:"Step 2: Create Physics Helper Class",id:"step-2-create-physics-helper-class",level:2},{value:"Step 3: Update GameLayer with Physics",id:"step-3-update-gamelayer-with-physics",level:2},{value:"Step 4: Understanding Physics Concepts",id:"step-4-understanding-physics-concepts",level:2},{value:"Key Physics Concepts:",id:"key-physics-concepts",level:3},{value:"Important Settings:",id:"important-settings",level:3},{value:"Step 5: Build and Test",id:"step-5-build-and-test",level:2},{value:"Step 6: Adding Debug Rendering (Optional)",id:"step-6-adding-debug-rendering-optional",level:2},{value:"Checkpoint: What Your Project Should Look Like",id:"checkpoint-what-your-project-should-look-like",level:2},{value:"New Files:",id:"new-files",level:3},{value:"What You Should See:",id:"what-you-should-see",level:3},{value:"Key Concepts Learned:",id:"key-concepts-learned",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Understanding Performance",id:"understanding-performance",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Download Checkpoint Project",id:"download-checkpoint-project",level:2}],c={toc:p},d="wrapper";function y(e){let{components:t,...n}=e;return(0,o.yg)(d,(0,i.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"part-2-physics-foundation"},"Part 2: Physics Foundation"),(0,o.yg)("p",null,"In this part, we'll implement Box2D physics in our platformer game, creating the foundation for realistic movement and collision detection."),(0,o.yg)("h2",{id:"what-well-accomplish"},"What We'll Accomplish"),(0,o.yg)("p",null,"By the end of this part, you'll have:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"A working Box2D physics world with gravity"),(0,o.yg)("li",{parentName:"ul"},"Understanding of physics coordinate systems"),(0,o.yg)("li",{parentName:"ul"},"Helper utilities for physics conversions"),(0,o.yg)("li",{parentName:"ul"},"A basic physics debug renderer"),(0,o.yg)("li",{parentName:"ul"},"Foundation for character and platform physics")),(0,o.yg)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Completed ",(0,o.yg)("a",{parentName:"li",href:"./part-1-setup"},"Part 1: Project Setup and Assets")),(0,o.yg)("li",{parentName:"ul"},"Understanding of basic physics concepts (gravity, velocity, forces)")),(0,o.yg)("h2",{id:"step-1-understanding-box2d-integration"},"Step 1: Understanding Box2D Integration"),(0,o.yg)("p",null,"cocos2d-mono comes with Box2D physics built-in. Box2D uses a different coordinate system and units than cocos2d:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Box2D units"),": Meters (optimal for objects 0.1 to 10 meters)"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"cocos2d units"),": Pixels"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Coordinate system"),": Box2D uses bottom-left origin, cocos2d uses variable origin")),(0,o.yg)("p",null,"We need conversion utilities to bridge these differences."),(0,o.yg)("h2",{id:"step-2-create-physics-helper-class"},"Step 2: Create Physics Helper Class"),(0,o.yg)("p",null,"Create a new file called ",(0,o.yg)("inlineCode",{parentName:"p"},"PhysicsHelper.cs"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-csharp"},"using Cocos2D;\nusing Box2D.Dynamics;\nusing Box2D.Collision.Shapes;\nusing Box2D.Common;\n\nnamespace Platformer\n{\n    public static class PhysicsHelper\n    {\n        // Physics constants\n        public const float PTM_RATIO = 32.0f; // Pixels to meters ratio\n\n        // Categories for collision filtering\n        public const ushort CATEGORY_PLAYER = 0x0001;\n        public const ushort CATEGORY_PLATFORM = 0x0002;\n        public const ushort CATEGORY_COLLECTIBLE = 0x0004;\n\n        // Convert from cocos2d coordinates to Box2D coordinates\n        public static b2Vec2 ToPhysicsVector(CCPoint point)\n        {\n            return new b2Vec2(point.X / PTM_RATIO, point.Y / PTM_RATIO);\n        }\n\n        // Convert from Box2D coordinates to cocos2d coordinates\n        public static CCPoint ToCocosVector(b2Vec2 vector)\n        {\n            return new CCPoint(vector.x * PTM_RATIO, vector.y * PTM_RATIO);\n        }\n        \n        // Create a rectangular physics body\n        public static b2Body CreateBoxBody(b2World world, float x, float y, float width, float height,\n            bool isDynamic = false, float density = 1.0f, float friction = 0.3f, float restitution = 0.1f)\n        {\n            // Define body\n            b2BodyDef bodyDef = new b2BodyDef();\n            bodyDef.position = new b2Vec2(x / PTM_RATIO, y / PTM_RATIO);\n            bodyDef.type = isDynamic ? b2BodyType.b2_dynamicBody : b2BodyType.b2_staticBody;\n\n            // Create body\n            b2Body body = world.CreateBody(bodyDef);\n\n            // Define fixture\n            b2PolygonShape shape = new b2PolygonShape();\n            shape.SetAsBox(width / (2 * PTM_RATIO), height / (2 * PTM_RATIO));\n            \n            b2FixtureDef fixtureDef = new b2FixtureDef();\n            fixtureDef.shape = shape;\n            fixtureDef.density = density;\n            fixtureDef.friction = friction;\n            fixtureDef.restitution = restitution;\n\n            // Add fixture to body\n            body.CreateFixture(fixtureDef);\n\n            return body;\n        }\n    }\n}\n")),(0,o.yg)("h2",{id:"step-3-update-gamelayer-with-physics"},"Step 3: Update GameLayer with Physics"),(0,o.yg)("p",null,"Now let's update our ",(0,o.yg)("inlineCode",{parentName:"p"},"GameLayer.cs")," to include Box2D physics:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-csharp"},'using Cocos2D;\nusing Box2D.Dynamics;\nusing System;\n\nnamespace Platformer\n{\n    public class GameLayer : CCLayer\n    {\n        // Physics world\n        private b2World physicsWorld;\n        private b2Body groundBody;\n        \n        // Physics settings\n        private const int VELOCITY_ITERATIONS = 8;\n        private const int POSITION_ITERATIONS = 3;\n        private const float TIME_STEP = 1.0f / 60.0f;\n        \n        public GameLayer()\n        {\n            // Get visible area size\n            CCSize visibleSize = CCDirector.SharedDirector.WinSize;\n            \n            // Initialize physics world\n            InitializePhysics(visibleSize);\n            \n            // Create background\n            CCSprite background = new CCSprite("background");\n            background.Position = new CCPoint(visibleSize.Width / 2, visibleSize.Height / 2);\n            \n            // Scale background to fit screen\n            float scaleX = visibleSize.Width / background.ContentSize.Width;\n            float scaleY = visibleSize.Height / background.ContentSize.Height;\n            background.Scale = Math.Max(scaleX, scaleY);\n            \n            AddChild(background, -1);\n            \n            // Create some test physics objects\n            CreateTestObjects(visibleSize);\n            \n            // Add labels for information\n            CCLabelTTF titleLabel = new CCLabelTTF("Platformer Tutorial - Part 2: Physics", "Arial", 24);\n            titleLabel.Position = new CCPoint(visibleSize.Width / 2, visibleSize.Height - 30);\n            titleLabel.Color = CCColor3B.White;\n            AddChild(titleLabel);\n            \n            CCLabelTTF infoLabel = new CCLabelTTF("Physics World Active - Objects will fall!", "Arial", 16);\n            infoLabel.Position = new CCPoint(visibleSize.Width / 2, visibleSize.Height - 60);\n            infoLabel.Color = CCColor3B.Yellow;\n            AddChild(infoLabel);\n            \n            // Enable updates to step the physics world\n            ScheduleUpdate();\n        }\n        \n        private void InitializePhysics(CCSize worldSize)\n        {\n            // Create physics world\n            physicsWorld = PhysicsHelper.CreateWorld();\n            \n            // Create world boundaries\n            groundBody = PhysicsHelper.CreateWorldBoundaries(physicsWorld, worldSize);\n            \n            // Set up contact listener for collision detection (we\'ll expand this later)\n            // physicsWorld.SetContactListener(new ContactListener());\n        }\n        \n        private void CreateTestObjects(CCSize visibleSize)\n        {\n            // Create some test boxes to demonstrate physics\n            for (int i = 0; i < 3; i++)\n            {\n                // Create a visual sprite\n                CCSprite testBox = new CCSprite("platform"); // Using platform texture as test\n                testBox.Position = new CCPoint(200 + i * 100, 400 + i * 50);\n                testBox.Color = new CCColor3B((byte)(100 + i * 50), (byte)(150 - i * 30), (byte)(200));\n                AddChild(testBox, 1);\n                \n                // Create corresponding physics body\n                b2Body physicsBody = PhysicsHelper.CreateDynamicBody(\n                    physicsWorld, \n                    testBox.Position, \n                    testBox.ContentSize,\n                    1.0f\n                );\n                \n                // Store reference to sprite in physics body user data\n                physicsBody.UserData = testBox;\n            }\n            \n            // Create a static platform to catch falling objects\n            CCSprite platform = new CCSprite("platform");\n            platform.Position = new CCPoint(visibleSize.Width / 2, 150);\n            platform.ScaleX = 4.0f; // Make it wider\n            AddChild(platform, 1);\n            \n            // Create static physics body for platform\n            b2Body platformBody = PhysicsHelper.CreateStaticBody(\n                physicsWorld,\n                platform.Position,\n                new CCSize(platform.ContentSize.Width * platform.ScaleX, platform.ContentSize.Height)\n            );\n            platformBody.UserData = platform;\n        }\n        \n        public override void Update(float dt)\n        {\n            base.Update(dt);\n            \n            // Step the physics world\n            physicsWorld.Step(TIME_STEP, VELOCITY_ITERATIONS, POSITION_ITERATIONS);\n            \n            // Update visual positions based on physics bodies\n            UpdateVisualPositions();\n        }\n        \n        private void UpdateVisualPositions()\n        {\n            // Iterate through all physics bodies and update their corresponding sprites\n            for (b2Body body = physicsWorld.BodyList; body != null; body = body.Next)\n            {\n                if (body.UserData is CCSprite sprite)\n                {\n                    // Convert physics position back to cocos2d coordinates\n                    CCPoint newPosition = PhysicsHelper.VectorToPoint(body.Position);\n                    sprite.Position = newPosition;\n                    \n                    // Update rotation if needed\n                    sprite.Rotation = -CCMathHelper.ToDegrees(body.Angle);\n                }\n            }\n        }\n        \n        protected override void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                // Clean up physics world\n                physicsWorld?.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n    }\n}\n')),(0,o.yg)("h2",{id:"step-4-understanding-physics-concepts"},"Step 4: Understanding Physics Concepts"),(0,o.yg)("h3",{id:"key-physics-concepts"},"Key Physics Concepts:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"World"),": The physics simulation container")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Bodies"),": Objects that can move and collide"),(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Static"),": Never moves (platforms, walls)"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Dynamic"),": Affected by forces (player, enemies)"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Kinematic"),": Moves but not affected by forces (moving platforms)"))),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Fixtures"),": Attach shapes to bodies and define material properties")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"Shapes"),": Define collision geometry (box, circle, polygon)"))),(0,o.yg)("h3",{id:"important-settings"},"Important Settings:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Density"),": Mass per unit area (affects how heavy objects feel)"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Friction"),": Resistance to sliding (0 = ice, 1 = rough surface)"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Restitution"),": Bounciness (0 = no bounce, 1 = perfectly elastic)")),(0,o.yg)("h2",{id:"step-5-build-and-test"},"Step 5: Build and Test"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Build the project (F6)"),(0,o.yg)("li",{parentName:"ol"},"Run the game (F5)")),(0,o.yg)("p",null,"You should see:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Your background"),(0,o.yg)("li",{parentName:"ul"},"Several colored boxes falling due to gravity"),(0,o.yg)("li",{parentName:"ul"},"Boxes landing on a platform and coming to rest"),(0,o.yg)("li",{parentName:"ul"},'Title showing "Part 2: Physics"')),(0,o.yg)("h2",{id:"step-6-adding-debug-rendering-optional"},"Step 6: Adding Debug Rendering (Optional)"),(0,o.yg)("p",null,"For development, it's helpful to see physics shapes. Add this to your GameLayer:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-csharp"},"// Add to the top of GameLayer.cs\nusing Box2D.Dynamics;\n\n// Add these fields to GameLayer class\nprivate bool showPhysicsDebug = true;\n\n// Add this method to GameLayer\nprivate void DrawPhysicsDebug()\n{\n    if (!showPhysicsDebug) return;\n    \n    // Simple debug drawing - draw rectangles for physics bodies\n    for (b2Body body = physicsWorld.BodyList; body != null; body = body.Next)\n    {\n        if (body.UserData is CCSprite sprite)\n        {\n            // Draw a simple outline around physics bodies\n            CCPoint position = PhysicsHelper.VectorToPoint(body.Position);\n            \n            // This is a simplified debug visualization\n            // In a full implementation, you'd want proper debug drawing\n        }\n    }\n}\n")),(0,o.yg)("h2",{id:"checkpoint-what-your-project-should-look-like"},"Checkpoint: What Your Project Should Look Like"),(0,o.yg)("p",null,"At this point, your project should have:"),(0,o.yg)("h3",{id:"new-files"},"New Files:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"PhysicsHelper.cs")," - Physics utility functions"),(0,o.yg)("li",{parentName:"ul"},"Updated ",(0,o.yg)("inlineCode",{parentName:"li"},"GameLayer.cs")," - Physics integration")),(0,o.yg)("h3",{id:"what-you-should-see"},"What You Should See:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Boxes falling from the top of the screen"),(0,o.yg)("li",{parentName:"ul"},"Objects landing on a platform and stopping"),(0,o.yg)("li",{parentName:"ul"},"Realistic physics behavior with gravity"),(0,o.yg)("li",{parentName:"ul"},"Smooth 60 FPS with physics simulation")),(0,o.yg)("h3",{id:"key-concepts-learned"},"Key Concepts Learned:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Box2D coordinate system and unit conversion"),(0,o.yg)("li",{parentName:"ul"},"Creating physics worlds and bodies"),(0,o.yg)("li",{parentName:"ul"},"Static vs dynamic physics bodies"),(0,o.yg)("li",{parentName:"ul"},"Physics simulation loop"),(0,o.yg)("li",{parentName:"ul"},"Synchronizing visual sprites with physics bodies")),(0,o.yg)("h2",{id:"troubleshooting"},"Troubleshooting"),(0,o.yg)("p",null,"Common issues and solutions:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Objects falling through platforms"),": Check that static bodies are created correctly"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Objects moving too fast"),": Adjust TIME_STEP or increase iteration counts"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Jittery movement"),": Ensure consistent frame rate and proper conversion ratios"),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("strong",{parentName:"li"},"Memory issues"),": Make sure to dispose of physics world properly")),(0,o.yg)("h2",{id:"understanding-performance"},"Understanding Performance"),(0,o.yg)("p",null,"Physics simulation can be expensive. Key performance tips:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Use appropriate iteration counts (8 velocity, 3 position is usually good)"),(0,o.yg)("li",{parentName:"ul"},"Don't create too many dynamic bodies"),(0,o.yg)("li",{parentName:"ul"},"Use static bodies for non-moving objects"),(0,o.yg)("li",{parentName:"ul"},"Consider sleeping inactive bodies")),(0,o.yg)("h2",{id:"next-steps"},"Next Steps"),(0,o.yg)("p",null,"Great work! You now have a solid physics foundation. In ",(0,o.yg)("a",{parentName:"p",href:"./part-3-player"},"Part 3: Player Character"),", we'll create a controllable player character that uses physics for movement and can interact with the world."),(0,o.yg)("p",null,"Key topics in Part 3:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Creating a player character class"),(0,o.yg)("li",{parentName:"ul"},"Implementing keyboard/gamepad input"),(0,o.yg)("li",{parentName:"ul"},"Physics-based movement and jumping"),(0,o.yg)("li",{parentName:"ul"},"Character animations"),(0,o.yg)("li",{parentName:"ul"},"Basic state management")),(0,o.yg)("h2",{id:"download-checkpoint-project"},"Download Checkpoint Project"),(0,o.yg)("p",null,"You can download the complete Part 2 project ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/brandmooffin/cocos2d-mono-samples/tree/main/Tutorial%20Samples/Platformer/Checkpoints/Part%202"},"here")," to compare with your implementation."))}y.isMDXComponent=!0}}]);